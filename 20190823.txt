
using System;
using System.Linq;
using SmartQuant;
using DeriSock;
using DeriSock.Converter;
using DeriSock.Model;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Concurrent;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;

namespace Deribit_framework
{
    public class MyBookInfo
    {
        public Instrument inst;
        public BookResponse br;
        public TradesInfo tr;
        public string[] chs;
        public PositionInfo pi;
        public MyBookInfo(Instrument inst, BookResponse br, TradesInfo tr, PositionInfo pi, string[] chs)
        {
            this.inst = inst;
            this.br = br;
            this.tr = tr;
            this.chs = chs;
            this.pi = pi;
        }
    }
    public class MyOrderInfo
    {
        public Order ord
        {
            get { return this.command.Order; }
            set { this.command.Order = value; }
        }

        public ExecutionCommand command;
        public BuySellResponse bsr;
        public MyOrderInfo(ExecutionCommand command, BuySellResponse bsr)
        {
            this.command = command;
            this.bsr = bsr;
        }
    }
    public class Deribit_new : Provider, IInstrumentProvider, IHistoricalDataProvider, IDataProvider, IExecutionProvider
    {
        //TODO: add timer for ui update
        //TODO: get and set locker?
        //TODO: win7 can't use .net websocket?
        //TODO: 連線放在connect函數
        //TODO: 連上線就把該帳號委託單都找回來


        DeribitApiV2 m_api = new DeriSock.DeribitApiV2("test.deribit.com");
        object m_lock1 = new object();
        ConcurrentDictionary<string, MyBookInfo> m_subscribedInst = new ConcurrentDictionary<string, MyBookInfo>();
        Aron.MultiKeyDictionary<string, int, MyOrderInfo> m_orders = new Aron.MultiKeyDictionary<string, int, MyOrderInfo>();




        public Deribit_new(Framework framework)
            : base(framework)
        {
            base.id = 89;  //seems like 0~100 is valid if it is unique, 101~255 is invalid even if it is unique
            base.name = "Deribit_2019Aug";
        }







        public void 連線()
        {
            //DeriSock.JsonRpcWebSocketClient socket = new DeriSock.JsonRpcWebSocketClient("wss://test.deribit.com/ws/api/v2");
            //socket.ConnectAsync();

            Task conn1 = m_api.ConnectAsync();
            conn1.Wait();

            Task<AuthResponse> conn2 = m_api.PublicAuthAsync("JuIyyQRu", "uwjmMeKs9jEGnCH1_OO8l10GN_bv25PGl2odWy-Ooy4", "apiconsole-mwc6qnvtf5");
            Object rtn2 = conn2.Result;

            if (m_api.IsConnected)
            {
                Task<string> conn3 = m_api.PingAsync();
                string rtn3 = conn3.Result;
            }
            else
            {
                throw new Exception("connection fail");
            }

            LoopUpdatePosition();
        }
        void LoopUpdatePosition()//TODO: 可以改成subscribe?
        {
            new Thread(() =>
            {
                while (true)
                {
                    Task<PositionInfo[]> rtn = m_api.PrivateGetPositionsAsync("BTC");

                    try
                    {
                        if (!rtn.Wait(1000))
                        {
                            continue;//unknow fail
                        }
                    }
                    catch
                    {
                        continue;//unknow fail
                    }

                    PositionInfo[] pis = rtn.Result;

                    foreach (PositionInfo pi in pis)
                    {
                        if (m_subscribedInst.TryGetValue(pi.instrument_name, out MyBookInfo bi))
                        {
                            bi.pi = pi;
                        }
                    }

                    SpinWait.SpinUntil(() => false, 1);//wait 1 mini sec, in case no subscribes
                }
            }).Start();
        }
        public override async/*dave*/  void Send(ExecutionCommand command)
        {
            try
            {
                switch (command.Type)
                {
                    case ExecutionCommandType.Send:
                        {
                            BuySellResponse bsr = null;

                            if (command.OrdType == SmartQuant.OrderType.Limit)
                            {
                                if (command.Side == OrderSide.Buy)
                                {
                                    bsr = await m_api.PrivateBuyLimitAsync(command.Symbol, command.Qty, command.Price, "test123");
                                }
                                else if (command.Side == OrderSide.Sell)
                                {
                                    bsr = await m_api.PrivateSellLimitAsync(command.Symbol, command.Qty, command.Price, "test123");
                                }
                            }
                            else if (command.OrdType == SmartQuant.OrderType.Market)
                            {
                                if (command.Side == OrderSide.Buy)
                                {
                                    bsr = await m_api.PrivateBuyMarketAsync(command.Symbol, command.Qty, "test123");
                                }
                                else if (command.Side == OrderSide.Sell)
                                {
                                    bsr = await m_api.PrivateSellMarketAsync(command.Symbol, command.Qty, "test123");
                                }
                            }


                            if (bsr != null)
                            {
                                m_orders.Add(bsr.order.order_id, command.Order.Id, new MyOrderInfo(command, bsr));
                                UserEmit(command, OrderStatus.New);
                                //CheckFill(bsr.trades, command);//比註冊channel收到訊息的時間還慢
                            }
                            else
                            {
                                UserEmit(command, OrderStatus.Rejected);
                                //TODO: 寫訊息  如果不是bsr格式  要怎麼寫??
                            }
                            break;
                        }

                    case ExecutionCommandType.Cancel:
                        {
                            MyOrderInfo oi = m_orders[command.Order.Id];
                            JObject rtn = (JObject)await m_api.PrivateCancelOrderAsync(oi.bsr.order.order_id);

                            TryParse(rtn["order_state"], out string order_state);

                            if (order_state == "cancelled")
                            {
                                m_orders.Remove(command.Order.Id);
                                UserEmit(command, OrderStatus.Cancelled);
                            }
                            else
                            {
                                base.EmitError("cancel fail, order state:"+ order_state);
                                UserEmit(command, OrderStatus.Rejected);
                            }
                            break;
                        }

                    case ExecutionCommandType.Replace:
                        {
                            MyOrderInfo oi = m_orders[command.Order.Id];
                            BuySellResponse bsr = await m_api.PrivateEditAsync(oi.bsr.order.order_id, command.Qty, command.Price);

                            if (bsr.order.order_id == oi.bsr.order.order_id)
                            {
                                oi.bsr = bsr;
                                UserEmit(command, OrderStatus.Replaced);
                                //CheckFill(bsr.trades, command);//比註冊channel收到訊息的時間還慢
                            }
                            else
                            {
                                UserEmit(command, OrderStatus.Rejected);
                                //TODO: 寫訊息  如果不是bsr格式  要怎麼寫??
                            }
                            break;
                        }
                }
            }
            catch (Exception e)
            {
                base.EmitError(command.Type+" fail, msg:"+e.ToString());
            }
        }
        public void SubscribeInstru_1(TradesInfo[] tis_calbak)
        {
            TradesInfo tr_last = tis_calbak.Last();

            m_subscribedInst.TryGetValue(tr_last.instrument_name, out MyBookInfo bi);
            bi.tr = tr_last;

            Trade trd = new Trade(DateTime.Now, this.id, bi.inst.Id, tr_last.price, tr_last.amount);
            base.EmitData(trd, true);
        }
        public void SubscribeInstru_2(BookResponse br_calbak)
        {
            m_subscribedInst.TryGetValue(br_calbak.instrument_name, out MyBookInfo bi);
            bi.br = br_calbak;


            Bid bid = new Bid(DateTime.Now, this.id, bi.inst.Id, br_calbak.Bid, (int)br_calbak.bids[0][1]);
            Ask ask = new Ask(DateTime.Now, this.id, bi.inst.Id, br_calbak.Ask, (int)br_calbak.asks[0][1]);

            base.EmitData(bid, true);
            base.EmitData(ask, true);
        }
        public void SubscribeInstru_3(OrderInfo oi_calbak)
        {
            MyOrderInfo oi = null;

            for (int i = 0; ; i++)//為了UI顯示與操作所需要的等待  自動交易情況下建議拿掉  改成只看交易所id  不考慮OQ id
            {
                if (i > 30)
                {
                    base.EmitError("subscribe feedback fail, no found in order dictionary");
                    return;
                }

                if (m_orders.TryGetValue(oi_calbak.order_id, out oi))
                    break;

                Thread.Sleep(100);
            }

            if (oi.bsr.order.filled_amount > oi_calbak.filled_amount || oi_calbak.order_state == "filled")
            {
                if (oi.bsr.order.filled_amount == oi_calbak.filled_amount)
                {
                    UserEmit(oi.command, OrderStatus.Filled);
                    m_orders.Remove(oi_calbak.order_id);
                }
                else
                {
                    UserEmit(oi.command, OrderStatus.PartiallyFilled);
                }
            }
            oi.bsr.order = oi_calbak;
        }
        public override void Subscribe(Instrument inst)
        {
            Task<bool> rtn1 = m_api.PublicSubscribeTradeAsync(inst.Symbol, 0, 10, SubscribeInstru_1, out string ch1);

            Task<bool> rtn2 = m_api.PublicSubscribeBookAsync(inst.Symbol, 0, 10, SubscribeInstru_2, out string ch2);

            Task<bool> rtn3 = m_api.PrivateSubscribeOrdersAsync(inst.Symbol, SubscribeInstru_3, out string ch3);

            //Task<bool> result4 = m_api.PrivateSubscribeOrdersAsync(inst.Symbol, SubscribeInstru_4);


            m_subscribedInst.TryAdd(inst.Symbol, new MyBookInfo(
                inst,
                null,
                null,
                null,
                new string[] { ch2, ch1, ch3 }
                ));


            if (!rtn1.Result)
            {
                base.EmitError("subscribe trade info fail");
                Unsubscribe(inst);
            }
            if (!rtn2.Result)
            {
                base.EmitError("subscribe book info fail");
                Unsubscribe(inst);
            }
            if (!rtn3.Result)
            {
                base.EmitError("subscribe order info fail");
                Unsubscribe(inst);
            }
        }
        public override void Unsubscribe(Instrument inst)
        {
            if (m_subscribedInst.TryRemove(inst.Symbol, out MyBookInfo bi))
            {
                Task<List<string>> result1 = m_api.UnsubscribePublicAsync(bi.chs);
            }
            else
            {
                base.EmitError("unsubscribe fail, no instrument found.");
            }
            //List<string> test = result1.Result;   //如果送出兩個  只回傳一個  代表只有一個成功被Unsubscribe
        }












        public void UserEmit(ExecutionCommand command, OrderStatus status)
        {
            ExecutionReport executionReport = new ExecutionReport(command);
            executionReport.OrdStatus = status;
            base.EmitExecutionReport(executionReport, true);
        }

        static bool TryParse(JToken j, out string s)
        {
            s = "";
            if (j != null)
            {  
                s = j.ToString();
                return true;
            }
            return false;
        }

        static bool TryParse(JToken j, out double d)
        {
            d = 0;
            if (j != null)
            {
                if (Double.TryParse(j.ToString(), out double d_))
                {
                    d = d_;
                    return true;
                }
            }
            return false;
        }

        static bool TryParse(JToken j, out int n)
        {
            n = 0;
            if (j != null)
            {
                if (Int32.TryParse(j.ToString(), out int n_))
                {
                    n = n_;
                    return true;
                }
            }
            return false;
        }

        static bool TryParse(JToken j, out long l)
        {
            l = 0;
            if (j != null)
            {
                if (Int64.TryParse(j.ToString(), out long l_))
                {
                    l = l_;
                    return true;
                }
            }
            return false;
        }

        static bool TryParse(JToken j, out DateTime dt)
        {
            dt = DateTime.Now;
            if (j != null)
            {
                if (Int64.TryParse(j.ToString(), out long l_))
                {
                    dt = DateTimeOffset.FromUnixTimeMilliseconds(l_).DateTime.ToLocalTime();
                    return true;
                }
            }
            return false;
        }
    }
}











namespace Aron
{
    public class MultiKeyDictionary<K, L, V>
    {
        internal readonly Dictionary<K, V> baseDictionary = new Dictionary<K, V>();
        internal readonly Dictionary<L, K> subDictionary = new Dictionary<L, K>();
        internal readonly Dictionary<K, L> primaryToSubkeyMapping = new Dictionary<K, L>();

        ReaderWriterLockSlim readerWriterLock = new ReaderWriterLockSlim();

        public V this[L subKey]
        {
            get
            {
                V item;
                if (TryGetValue(subKey, out item))
                    return item;

                throw new KeyNotFoundException("sub key not found: " + subKey.ToString());
            }
        }

        public V this[K primaryKey]
        {
            get
            {
                V item;
                if (TryGetValue(primaryKey, out item))
                    return item;

                throw new KeyNotFoundException("primary key not found: " + primaryKey.ToString());
            }
        }

        public void Associate(L subKey, K primaryKey)
        {
            readerWriterLock.EnterUpgradeableReadLock();

            try
            {
                if (!baseDictionary.ContainsKey(primaryKey))
                    throw new KeyNotFoundException(string.Format("The base dictionary does not contain the key '{0}'", primaryKey));

                if (primaryToSubkeyMapping.ContainsKey(primaryKey)) // Remove the old mapping first
                {
                    readerWriterLock.EnterWriteLock();

                    try
                    {
                        if (subDictionary.ContainsKey(primaryToSubkeyMapping[primaryKey]))
                        {
                            subDictionary.Remove(primaryToSubkeyMapping[primaryKey]);
                        }

                        primaryToSubkeyMapping.Remove(primaryKey);
                    }
                    finally
                    {
                        readerWriterLock.ExitWriteLock();
                    }
                }

                subDictionary[subKey] = primaryKey;
                primaryToSubkeyMapping[primaryKey] = subKey;
            }
            finally
            {
                readerWriterLock.ExitUpgradeableReadLock();
            }
        }

        public bool TryGetValue(L subKey, out V val)
        {
            val = default(V);

            K primaryKey;

            readerWriterLock.EnterReadLock();

            try
            {
                if (subDictionary.TryGetValue(subKey, out primaryKey))
                {
                    return baseDictionary.TryGetValue(primaryKey, out val);
                }
            }
            finally
            {
                readerWriterLock.ExitReadLock();
            }

            return false;
        }

        public bool TryGetValue(K primaryKey, out V val)
        {
            readerWriterLock.EnterReadLock();

            try
            {
                return baseDictionary.TryGetValue(primaryKey, out val);
            }
            finally
            {
                readerWriterLock.ExitReadLock();
            }
        }

        public bool ContainsKey(L subKey)
        {
            V val;

            return TryGetValue(subKey, out val);
        }

        public bool ContainsKey(K primaryKey)
        {
            V val;

            return TryGetValue(primaryKey, out val);
        }

        public void Remove(K primaryKey)
        {
            readerWriterLock.EnterWriteLock();

            try
            {
                if (primaryToSubkeyMapping.ContainsKey(primaryKey))
                {
                    if (subDictionary.ContainsKey(primaryToSubkeyMapping[primaryKey]))
                    {
                        subDictionary.Remove(primaryToSubkeyMapping[primaryKey]);
                    }

                    primaryToSubkeyMapping.Remove(primaryKey);
                }

                baseDictionary.Remove(primaryKey);
            }
            finally
            {
                readerWriterLock.ExitWriteLock();
            }
        }

        public void Remove(L subKey)
        {
            readerWriterLock.EnterWriteLock();

            try
            {
                baseDictionary.Remove(subDictionary[subKey]);

                primaryToSubkeyMapping.Remove(subDictionary[subKey]);

                subDictionary.Remove(subKey);
            }
            finally
            {
                readerWriterLock.ExitWriteLock();
            }
        }

        public void Add(K primaryKey, V val)
        {
            readerWriterLock.EnterWriteLock();

            try
            {
                baseDictionary.Add(primaryKey, val);
            }
            finally
            {
                readerWriterLock.ExitWriteLock();
            }
        }

        public void Add(K primaryKey, L subKey, V val)
        {
            Add(primaryKey, val);

            Associate(subKey, primaryKey);
        }

        public V[] CloneValues()
        {
            readerWriterLock.EnterReadLock();

            try
            {
                V[] values = new V[baseDictionary.Values.Count];

                baseDictionary.Values.CopyTo(values, 0);

                return values;
            }
            finally
            {
                readerWriterLock.ExitReadLock();
            }
        }

        public List<V> Values
        {
            get
            {
                readerWriterLock.EnterReadLock();

                try
                {
                    return baseDictionary.Values.ToList();
                }
                finally
                {
                    readerWriterLock.ExitReadLock();
                }
            }
        }

        public K[] ClonePrimaryKeys()
        {
            readerWriterLock.EnterReadLock();

            try
            {
                K[] values = new K[baseDictionary.Keys.Count];

                baseDictionary.Keys.CopyTo(values, 0);

                return values;
            }
            finally
            {
                readerWriterLock.ExitReadLock();
            }
        }

        public L[] CloneSubKeys()
        {
            readerWriterLock.EnterReadLock();

            try
            {
                L[] values = new L[subDictionary.Keys.Count];

                subDictionary.Keys.CopyTo(values, 0);

                return values;
            }
            finally
            {
                readerWriterLock.ExitReadLock();
            }
        }

        public void Clear()
        {
            readerWriterLock.EnterWriteLock();

            try
            {
                baseDictionary.Clear();

                subDictionary.Clear();

                primaryToSubkeyMapping.Clear();
            }
            finally
            {
                readerWriterLock.ExitWriteLock();
            }
        }

        public int Count
        {
            get
            {
                readerWriterLock.EnterReadLock();

                try
                {
                    return baseDictionary.Count;
                }
                finally
                {
                    readerWriterLock.ExitReadLock();
                }
            }
        }

        public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
        {
            readerWriterLock.EnterReadLock();

            try
            {
                return baseDictionary.GetEnumerator();
            }
            finally
            {
                readerWriterLock.ExitReadLock();
            }
        }
    }
}